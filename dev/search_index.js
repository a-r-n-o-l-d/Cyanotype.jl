var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Cyanotype","category":"page"},{"location":"#Cyanotype","page":"Home","title":"Cyanotype","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Cyanotype.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Cyanotype]","category":"page"},{"location":"#Cyanotype.AxialDWConvBp","page":"Home","title":"Cyanotype.AxialDWConvBp","text":"https://arxiv.org/pdf/2306.16103v2.pdf\n\nKeyword arguments:\n\nvol: indicates a building process for three-dimensionnal data (default\n\nfalse)\n\nact: activation function (default identity)\nstride is not documented\npad is not documented\ndila is not documented\ninit is not documented\nnorm is not documented\nskip is not documented\n\n\n\n\n\n","category":"type"},{"location":"#Cyanotype.BatchNormBp","page":"Home","title":"Cyanotype.BatchNormBp","text":"Wraps a Flux.Batchnorm\n\nKeyword arguments:\n\nact: activation function (default identity)\ninitshift: see initβ (default zeros32)\ninitscale: see initγ (default ones32)\naffine: see affine (default true)\ntrackstats: see track_stats (default true)\nepsilon: see eps (default 1.0e-5)\nmomentum: see momentum (default 0.1)\n\n\n\n\n\n","category":"type"},{"location":"#Cyanotype.CBAMBp","page":"Home","title":"Cyanotype.CBAMBp","text":"\n\n\n\n","category":"type"},{"location":"#Cyanotype.ChannelAttentionBp","page":"Home","title":"Cyanotype.ChannelAttentionBp","text":"\n\n\n\n","category":"type"},{"location":"#Cyanotype.ChannelExpansionConvBp","page":"Home","title":"Cyanotype.ChannelExpansionConvBp","text":"\n\n\n\n","category":"type"},{"location":"#Cyanotype.ConvBp","page":"Home","title":"Cyanotype.ConvBp","text":"ConvBp(; kwargs...)\n\nA cyanotype blueprint describing a convolutionnal module or layer depending om the value of norm argument.\n\nKeyword arguments:\n\nvol: indicates a building process for three-dimensionnal data (default\n\nfalse)\n\nact: activation function (default identity)\nnorm:\ndwise:\nrvnorm:\npreact:\nbias:\nstride: see stride (default 1)\npad: see pad (default Flux.SamePad())\ndila: see dilation (default 1)\ngroups: see groups (default 1)\ninit: see init (default glorot_uniform)\n\n\n\n\n\n","category":"type"},{"location":"#Cyanotype.ConvTransposeUpsamplerBp","page":"Home","title":"Cyanotype.ConvTransposeUpsamplerBp","text":"Keyword arguments:\n\nvol: indicates a building process for three-dimensionnal data (default\n\nfalse)\n\nscale is not documented\nbias is not documented\ninit is not documented\n\n\n\n\n\n","category":"type"},{"location":"#Cyanotype.DepthwiseConvBp","page":"Home","title":"Cyanotype.DepthwiseConvBp","text":"\n\n\n\n","category":"type"},{"location":"#Cyanotype.DoubleConvBp","page":"Home","title":"Cyanotype.DoubleConvBp","text":"DoubleConvBp(; kwargs)\n\nDescribes a convolutionnal module formed by two successive convolutionnal modules.\n\nKeyword arguments:\n\n\nconv2 is not documented\n\n\n\n\n\n","category":"type"},{"location":"#Cyanotype.EfficientNetBp","page":"Home","title":"Cyanotype.EfficientNetBp","text":"\n\n\n\n","category":"type"},{"location":"#Cyanotype.EfficientNetStageBp","page":"Home","title":"Cyanotype.EfficientNetStageBp","text":"Keyword arguments:\n\n\n\n\n\nwscaling is not documented\ndscaling is not documented\n\n\n\n\n\n","category":"type"},{"location":"#Cyanotype.EfficientUNetBp","page":"Home","title":"Cyanotype.EfficientUNetBp","text":"Keyword arguments:\n\n\n\nhead is not documented\n\n\n\n\n\n","category":"type"},{"location":"#Cyanotype.FusedMbConvBp","page":"Home","title":"Cyanotype.FusedMbConvBp","text":"\n\n\n\n","category":"type"},{"location":"#Cyanotype.GroupNormBp","page":"Home","title":"Cyanotype.GroupNormBp","text":"GroupNormBp(; kwargs...)\n\nDescribes a building process for a Groupnorm layer. make(channels, bp::CyGroupNorm)\n\nKeyword arguments:\n\nact: activation function (default identity)\ngroups: the number of groups passed to GroupNorm\n\nconstructor\n\ninitshift: see initβ (default zeros32)\ninitscale: see initγ (default ones32)\naffine: see affine (default true)\nepsilon: see eps (default 1.0e-5)\nmomentum: see momentum (default 0.1)\n\n\n\n\n\n","category":"type"},{"location":"#Cyanotype.HybridAtrouConvBp","page":"Home","title":"Cyanotype.HybridAtrouConvBp","text":"aka Hybrid Dilated Convolution paper example example\n\n\n\n\n\n","category":"type"},{"location":"#Cyanotype.InstanceNormBp","page":"Home","title":"Cyanotype.InstanceNormBp","text":"InstanceNormBp(; kwargs...)\n\nDescribes a building process for a InstanceNorm layer. make(channels, bp::CyInstanceNorm)\n\nKeyword arguments:\n\nact: activation function (default identity)\ninitshift: see initβ (default zeros32)\ninitscale: see initγ (default ones32)\naffine: see affine (default false)\ntrackstats: see track_stats (default false)\nepsilon: see eps (default 1.0e-5)\nmomentum: see momentum (default 0.1)\n\n\n\n\n\n","category":"type"},{"location":"#Cyanotype.KwargsMapping","page":"Home","title":"Cyanotype.KwargsMapping","text":"KwargsMapping(; flux_function = :notflux, field_names = (), flargs = (),\n                ftypes = (), defval = ())\n\nDefines a mapping of keyword arguments to interface a blueprint with a Flux function or constructor.\n\n\n\n\n\n","category":"type"},{"location":"#Cyanotype.LabelClassifierBp","page":"Home","title":"Cyanotype.LabelClassifierBp","text":"Keyword arguments:\n\n\ndropout is not documented\n\n\n\n\n\n","category":"type"},{"location":"#Cyanotype.LinearUpsamplerBp","page":"Home","title":"Cyanotype.LinearUpsamplerBp","text":"Keyword arguments:\n\nvol: indicates a building process for three-dimensionnal data (default\n\nfalse)\n\nscale is not documented\n\n\n\n\n\n","category":"type"},{"location":"#Cyanotype.MaxDownsamplerBp","page":"Home","title":"Cyanotype.MaxDownsamplerBp","text":"Keyword arguments:\n\nvol: indicates a building process for three-dimensionnal data (default\n\nfalse)\n\nwsize is not documented\n\n\n\n\n\n","category":"type"},{"location":"#Cyanotype.MbConvBp","page":"Home","title":"Cyanotype.MbConvBp","text":"\n\n\n\n","category":"type"},{"location":"#Cyanotype.MeanDownsamplerBp","page":"Home","title":"Cyanotype.MeanDownsamplerBp","text":"Keyword arguments:\n\nvol: indicates a building process for three-dimensionnal data (default\n\nfalse)\n\nwsize is not documented\n\n\n\n\n\n","category":"type"},{"location":"#Cyanotype.MeanMaxDownsamplerBp","page":"Home","title":"Cyanotype.MeanMaxDownsamplerBp","text":"\n\n\n\n","category":"type"},{"location":"#Cyanotype.NConvBp","page":"Home","title":"Cyanotype.NConvBp","text":"Template describing a module with N NConvBp repeated.\n\nKeyword arguments:\n\n\n\n\n\n\n\n","category":"type"},{"location":"#Cyanotype.NearestUpsamplerBp","page":"Home","title":"Cyanotype.NearestUpsamplerBp","text":"Keyword arguments:\n\nvol: indicates a building process for three-dimensionnal data (default\n\nfalse)\n\nscale is not documented\n\n\n\n\n\n","category":"type"},{"location":"#Cyanotype.PixelClassifierBp","page":"Home","title":"Cyanotype.PixelClassifierBp","text":"\n\n\n\n","category":"type"},{"location":"#Cyanotype.PixelMapBp","page":"Home","title":"Cyanotype.PixelMapBp","text":"\n\n\n\n","category":"type"},{"location":"#Cyanotype.PixelShuffleUpsamplerBp","page":"Home","title":"Cyanotype.PixelShuffleUpsamplerBp","text":"\n\n\n\n","category":"type"},{"location":"#Cyanotype.PointwiseConvBp","page":"Home","title":"Cyanotype.PointwiseConvBp","text":"\n\n\n\n","category":"type"},{"location":"#Cyanotype.ResCBAMBp","page":"Home","title":"Cyanotype.ResCBAMBp","text":"\n\n\n\n","category":"type"},{"location":"#Cyanotype.ResidualConvBp","page":"Home","title":"Cyanotype.ResidualConvBp","text":"Keyword arguments:\n\n\nconnector is not documented\n\n\n\n\n\n","category":"type"},{"location":"#Cyanotype.SpatialAttentionBp","page":"Home","title":"Cyanotype.SpatialAttentionBp","text":"\n\n\n\n","category":"type"},{"location":"#Cyanotype.SqueezeExcitationBp","page":"Home","title":"Cyanotype.SqueezeExcitationBp","text":"https://arxiv.org/pdf/1709.01507.pdf\n\n\n\n\n\n","category":"type"},{"location":"#Cyanotype.UBridgeBp","page":"Home","title":"Cyanotype.UBridgeBp","text":"Keyword arguments:\n\n\n\n\n\n\n\n\n\n","category":"type"},{"location":"#Cyanotype.UDecoderBp","page":"Home","title":"Cyanotype.UDecoderBp","text":"Keyword arguments:\n\n\n\n\n\n\n\n\n","category":"type"},{"location":"#Cyanotype.UEncoderBp","page":"Home","title":"Cyanotype.UEncoderBp","text":"Keyword arguments:\n\n\n\n\n\n\n\n\n","category":"type"},{"location":"#Cyanotype.UNet2Bp","page":"Home","title":"Cyanotype.UNet2Bp","text":"Keyword arguments:\n\nin_chs is not documented\nnlvl is not documented\nbwidth is not documented\nexpn is not documented\nksize is not documented\n\n\n\nstem is not documented\npath is not documented\nhead is not documented\ntop is not documented\nresidual is not documented\n\n\n\n\n\n","category":"type"},{"location":"#Cyanotype.UNetBp","page":"Home","title":"Cyanotype.UNetBp","text":"Keyword arguments:\n\nin_chs is not documented\nnlvl is not documented\nbwidth is not documented\nexpn is not documented\nksize is not documented\n\n\n\nstem is not documented\npath is not documented\nhead is not documented\ntop is not documented\n\n\n\n\n\n","category":"type"},{"location":"#Cyanotype.chcat-Tuple","page":"Home","title":"Cyanotype.chcat","text":"chcat(x...)\n\nConcatenates the provided data along the channel dimension positioned as the penultimate dimension.\n\nExample\n\njulia> x1 = rand(32, 32, 4, 6); # a batch of 6 images (32x32) with 4 channels\n\njulia> x2 = rand(32, 32, 4, 6); # a batch of 6 images (32x32) with 4 channels\n\njulia> chcat(x1, x2) |> size\n(32, 32, 8, 6)\n\n\n\n\n\n","category":"method"},{"location":"#Cyanotype.chmaxpool-Tuple{Any}","page":"Home","title":"Cyanotype.chmaxpool","text":"chmaxpool(x)\n\nPools all channels using the maximum function.\n\nExample\n\njulia> x = rand(2, 2, 3, 1);\n\njulia> Cyanotype.chmaxpool(x)\n2×2×1×1 Array{Float64, 4}:\n[:, :, 1, 1] =\n 0.930081  0.648555\n 0.759567  0.803717\n\n\n\n\n\n","category":"method"},{"location":"#Cyanotype.chmeanpool-Tuple{Any}","page":"Home","title":"Cyanotype.chmeanpool","text":"chmeanpool(x)\n\nPools all channels using the mean function.\n\nExample\n\n```julia julia> x = rand(2, 2, 3, 1);\n\njulia> chmeanpool(x) 2×2×1×1 Array{Float64, 4}: [:, :, 1, 1] =  0.64925   0.242134  0.153542  0.312039  ```\n\n\n\n\n\n","category":"method"},{"location":"#Cyanotype.chsoftmax-Tuple{Any}","page":"Home","title":"Cyanotype.chsoftmax","text":"chsoftmax(x)\n\nApply a softmax function along the channel dimension. This function is useful for pixel classification (semantic segmentation).\n\nExample\n\njulia> x = rand(2, 2, 3, 1);\n\njulia> sum(chsoftmax(x), dims=3)\n2×2×1×1 Array{Float64, 4}:\n[:, :, 1, 1] =\n 1.0  1.0\n 1.0  1.0\n\nSee also PixelClassifierBp.\n\n\n\n\n\n","category":"method"},{"location":"#Cyanotype.cyanotype","page":"Home","title":"Cyanotype.cyanotype","text":"cyanotype(bp::AbstractBlueprint; kwargs...)\n\nCreates a new blueprint from bp with the modifications defined by kwargs. This method is automatically generated by the @cyanotype macro during the process of defining a blueprint.\n\n\n\n\n\n","category":"function"},{"location":"#Cyanotype.flatten_layers-Tuple","page":"Home","title":"Cyanotype.flatten_layers","text":"flatten_layers(layers...)\n\nFlatten a nested Vector/Tuple/Chain into a single Vector. If any layers contains identity function it is skipped.\n\nExample\n\njulia> flatten_layers([\"a\",(\"b\",\"c\",[\"d\",\"e\",identity])])\n5-element Vector{Any}:\n \"a\"\n \"b\"\n \"c\"\n \"d\"\n \"e\"\n\n\n\n\n\n","category":"method"},{"location":"#Cyanotype.genk-Tuple{Any, Any}","page":"Home","title":"Cyanotype.genk","text":"genk(k, vol)\n\nHelping function used to generate a kernel tuple (k,k) or (k,k,k) if vol is true.\n\n\n\n\n\n","category":"method"},{"location":"#Cyanotype.make","page":"Home","title":"Cyanotype.make","text":"\n\n\n\n","category":"function"},{"location":"#Cyanotype.spread-Tuple{Any, Any, Any}","page":"Home","title":"Cyanotype.spread","text":"spread(bp, fieldname, old => new)\n\nCreate a new blueprint from bp for the given fieldname, and replace each occurence of old with new. This function allows to modify all nested blueprints at once.\n\nExample\n\njulia> # Create a blueprint for a Hybrid A-trou Convolution unit. By default activation\n       # functions are identity.\n\njulia> hac = HybridAtrouConvBp();\n\njulia> hac.conv.act |> println\nidentity\n\njulia> # Create a blueprint for a double convolution unit with a second convolution as a\n       # usual convolutionnal layer with `relu` as activation.\n\njulia> conv = DoubleConvBp(; conv1 = hac, conv2 = ConvBp(act = relu));\n\njulia> # Now let change all activation functions from relu to leakyrelu\n\njulia> bp = spread(conv, :act, identity => leakyrelu);\n\njulia> bp.conv1.conv.act |> println\nleakyrelu\n\njulia> bp.conv2.act |> println\nrelu\n\n\n\n\n\n","category":"method"},{"location":"#Cyanotype.spread-Tuple{Any}","page":"Home","title":"Cyanotype.spread","text":"spread(bp; kwargs...)\n\nCreate a new blueprint with kwargs spreaded over all fields of bp. This function allows to modify all nested blueprint at once.\n\nExample\n\njulia> # Create a blueprint for a Hybrid A-trou Convolution unit. By default activation\n       # functions are `identity`.\n\njulia> hac = HybridAtrouConvBp();\n\njulia> hac.conv.act |> println\nidentity\n\njulia> # Create a blueprint for a double convolution unit a the second convolution as a\n       # usual convolutionnal layer. By default activation function is `identity`.\n\njulia> conv = DoubleConvBp(; conv1 = hac, conv2 = ConvBp());\n\njulia> # Now let change all activation functions from relu to leakyrelu\n\njulia> bp = spread(conv; act = leakyrelu);\n\njulia> bp.conv1.conv.act |> println\nleakyrelu\n\njulia> bp.conv2.act |> println\nleakyrelu\n\n\n\n\n\n","category":"method"},{"location":"#Cyanotype.uchain-Tuple{}","page":"Home","title":"Cyanotype.uchain","text":"uchain(; encoders, decoders, bridge, connection, [paths])\n\nBuild a Chain with U-Net like architecture. encoders and decoders are vectors of encoding/decoding blocks, from top to bottom (see diagram below). bridge is the bottom part of U-Net  architecture. Each level of the U-Net is connected through a channel concatenation (◊ symbol in the diagram below).\n\nNotes :\n\nusually encoder unit starts with a 'MaxPool' to downsample image by 2, except the first\n\nlevel encoder.\n\nusually decoder unit ends with a 'ConvTranspose' to upsample image by 2, except the first\n\nlevel decoder.\n\n┌─────────┐                                                          ┌─────────┐\n│Encoder 1│                                                          │Decoder 1│\n└────┬────┘                                                          └─────────┘\n     │                                                                    ▴\n     │                                                                    │\n     ├───────────────────────────────────────────────────────────────────▸◊\n     │    ┌─────────┐                                     ┌─────────┐     │\n     └───▸│Encoder 2│                                     │Decoder 2├─────┘\n          └────┬────┘                                     └─────────┘\n               │                                               ▴\n               │                                               │\n               ├──────────────────────────────────────────────▸◊\n               │     ┌─────────┐               ┌─────────┐     │\n               └────▸│Encoder 3│               │Decoder 3├─────┘\n                     └────┬────┘               └─────────┘\n                          │                         ▴\n                          │                         │\n                          ├────────────────────────▸◊\n                          │       ┌─────────┐       │\n                          └──────▸│ Bridge  ├───────┘\n                                  └─────────┘\n\nSee also chcat.\n\n\n\n\n\n","category":"method"},{"location":"#Cyanotype.@activation-Tuple{Any}","page":"Home","title":"Cyanotype.@activation","text":"@activation(func)\n\nHelping macro used to define an activation function within a blueprint definition.\n\n\n\n\n\n","category":"macro"},{"location":"#Cyanotype.@cyanotype-Tuple{Any}","page":"Home","title":"Cyanotype.@cyanotype","text":"@cyanotype(expr)\n@cyanotype begin\n    [kmap]\n    [doc]\n    expr\nend\n\nDefines a blueprint DataType with documentation doc and a struct declaration defined in expr. If the blueprint directly refers to a Flux function or constructor, kmap is the name of keyword arguments mapping. If there is some fields documentation in expr, it is automatically appended to doc.\n\nAutomatically generated functions:\n\nFooBluePrint(; kwargs...): keyword argument constructor for FooBluePrint\nmapping(::FooBluePrint): return, if defined, the mapping kmap\ncyanotype(bp::FooBluePrint; kwargs...)\nkwargs(bp::FooBluePrint): return, if defined, a Dict with the keyword arguments for\n\nthe Flux function or constructor, it can be used as follow: flux_function(arg1, arg2; kwargs(bp)...)\n\nExample:\n\nusing Cyanotype\n\n@cyanotype begin\n    \"\"\"\n    A FooBlueprint as example.\n    \"\"\"\n    struct FooBlueprint{A<:Function}\n        \"\"\"`act`: activation function\"\"\"\n        act::A = relu\n    end\nend\n\nFor the keyword arguments mapping usage, see KwargsMapping documentation.\n\n\n\n\n\n","category":"macro"},{"location":"#Cyanotype.@volume-Tuple{}","page":"Home","title":"Cyanotype.@volume","text":"@volume\n\nHelping macro to define 'vol' field within a blueprint definition.\n\n\n\n\n\n","category":"macro"}]
}
